var M=Object.defineProperty;var v=(s,i,t)=>i in s?M(s,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[i]=t;var o=(s,i,t)=>(v(s,typeof i!="symbol"?i+"":i,t),t);import{K as n}from"./painterState.2081fc22.js";import{B as f}from"./pointer.1f73fbf8.js";import{p as Y,c as e,f as m,a as w,b as r,d as h,s as d,e as l,m as c,i as R}from"./vendor.86045b5f.js";class U{constructor(i){o(this,"position",[0,0,0]);o(this,"rotationX",0);o(this,"rotationY",0);o(this,"rotationXMat",e());o(this,"rotationYMat",e());o(this,"projectionMat",e());o(this,"viewMat",e());o(this,"needsUpdateView",!0);Object.assign(this,i),this.updateRotationX(),this.updateRotationY()}updateRotationX(i=0){this.rotationX+=i,m(this.rotationXMat,this.rotationX),this.needsUpdateView=!0}updateRotationY(i=0){this.rotationY+=i,w(this.rotationYMat,this.rotationY),this.needsUpdateView=!0}moveForward(i){const t=r(this.rotationYMat[8],this.rotationYMat[9],this.rotationYMat[10]);h(this.position,this.position,d(t,t,-i)),this.needsUpdateView=!0}moveLeft(i){const t=r(this.rotationYMat[0],this.rotationYMat[1],this.rotationYMat[2]);h(this.position,this.position,d(t,t,-i)),this.needsUpdateView=!0}moveUp(i){const t=r(this.rotationYMat[4],this.rotationYMat[5],this.rotationYMat[6]);h(this.position,this.position,d(t,t,i)),this.needsUpdateView=!0}update(){this.needsUpdateView&&(l(this.viewMat,this.position),c(this.viewMat,this.viewMat,this.rotationYMat),c(this.viewMat,this.viewMat,this.rotationXMat),R(this.viewMat,this.viewMat),this.needsUpdateView=!1)}}class P extends U{constructor(i){super(i);o(this,"fovy",Math.PI*.6);o(this,"aspect",1);o(this,"near",.1);o(this,"far",1e3);o(this,"needsUpdateProjection",!0);Object.assign(this,i),this.update()}update(){super.update(),this.needsUpdateProjection&&(Y(this.projectionMat,this.fovy,this.aspect,this.near,this.far),this.needsUpdateProjection=!1)}}function V(s){return class extends s{updatePosFromInput(i,t,a){!(t||a)||(((t==null?void 0:t[n.UP])||(t==null?void 0:t[n.W])||(a==null?void 0:a.holding)&&!a.pressed[f.RIGHT])&&this.moveForward(i),((t==null?void 0:t[n.DOWN])||(t==null?void 0:t[n.S])||(a==null?void 0:a.pressed[f.RIGHT]))&&this.moveForward(-i),((t==null?void 0:t[n.LEFT])||(t==null?void 0:t[n.A]))&&this.moveLeft(i),((t==null?void 0:t[n.RIGHT])||(t==null?void 0:t[n.D]))&&this.moveLeft(-i))}}}function I(s){return class extends s{constructor(){super(...arguments);o(this,"_oldMouse",{x:0,y:0})}updateRotFromPointer(i,t){const a=this._oldMouse;if(t.dragging){const p=a.x-t.drag.x,u=a.y-t.drag.y;a.x=t.drag.x,a.y=t.drag.y,u&&this.updateRotationX(u*i),p&&this.updateRotationY(p*i)}else a.x&&(a.x=0),a.y&&(a.y=0)}}}export{P,V as W,I as a};
